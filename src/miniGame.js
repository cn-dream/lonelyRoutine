/**
 *   Main implementation of Minilisim Game
 *
 *  * 
 * 
 * Date 2017/2/9
 * Author Jason
 * 
 */

import Game from './lib/gameEngine.js';
import Event from './lib/observer.js';
import {Sprite,SpriteAnimator,ImagePainter} from './lib/sprites';
import * as Behavior from './lib/behavior.js' ;
import * as Arc from './common/arc.js';
import * as Animate from './common/animate';

var game =new Game('miniGame','canvas'),
    loading=false, // loading flag

    //Score
    score=0,
    lastScore=0,
    lastScoreUpdate=undefined,

    //High score
    HIGH_SCORES_DISPLAYED=10,

    //Paused
    
    //Over
    gameOver=false,


    //Key Listeners
    lastKeyListenerTime=0, //For throttling arrow keys

    //Scrolling the background........
    translateDelta=1, //0.025
    translateOffset=0,

    // Lives......................................................
    livesLeft = 1,

    //random color , 5s change once?
    // It needs to be an array, store the color of bottom rect
    // Length depends of the RECT_NUM
    // And contains every 
    ranColor=[],
    spriteColor=[],
    //Canvas
    CANVAS_WIDTH=game.context.canvas.width,
    CANVAS_HEIGHT=game.context.canvas.height,

        //Sun Constants
    SUN_TOP=CANVAS_HEIGHT*0.1,//CANVAS_WIDTH/2,
    SUN_LEFT=CANVAS_WIDTH*0.8,
    SUN_RADIUS=30,

    //Rounded Rect
    RECT_NUM=4,
    RECT_STROKE_STYLE= '#0099FF',
   //Accurate fill style  should be generated by a algorithm  
    FILL_STYLES=['red','blue','green','chocolate','purple','orange','gray','magenta'],
    //4 means 
    RECT_WIDTH=CANVAS_WIDTH/RECT_NUM,
    RECT_HEIGHT=CANVAS_HEIGHT/3,

    CORNER_RADIUS=12,
    BALL_LAUNCH_LEFT=CANVAS_WIDTH/3,
    BALL_LAUNCH_TOP=RECT_HEIGHT*1.5,
    BALL_HEIGHT=CANVAS_WIDTH*0.08,
    BALL_WIDTH=BALL_HEIGHT,
    BALL_STROKE_STYLE='LightGrey',
    BALL_FILL_STYLES='LightCoral'
    ;

//滚动实现： 先计算出绘制图层需要对坐标系进行平移的距离，然后保存
//绘图环境对象的状态，平移坐标原点，并将每个图层之中的物体绘制出来，
//最后回复绘图环境对象
let scrollBackground=function(){
    //translate the canvas;
        //console.log('run background');
        let context=game.context;
        context.save();
        //%game.context.canvas.witdh;
        translateOffset=translateOffset<context.canvas.width?
                            (translateOffset+translateDelta):0;
       // console.log(translateOffset);
        context.translate(-translateOffset,0);

// Two image actually ! Use one to cover the gap of another 
// 两张图片(两个图形)，一个去弥补另一个
        paintNearCloud(context,120,20);
        paintNearCloud(context,context.canvas.width+120,20);

        //Paint Bottom 
        paintBottomRect(context,0);
        //It must be context.canvas.width ！if context.canvas.width-50
        //then it will be 50 gap! 
        paintBottomRect(context,context.canvas.width);
        context.restore();
    },

    //Paint methods
    //
    paintBottomRect=function(context,offset){
        let y=context.canvas.height-RECT_HEIGHT;//x
        //change too fast , 
        //let ranColor=generateRandom();

        for( let i=0;i<RECT_NUM;i++){
            let x=offset+RECT_WIDTH*i;
            Arc.drawRoundedRect(RECT_STROKE_STYLE,ranColor[i],
                                            x,y,RECT_WIDTH,
                                            RECT_HEIGHT,CORNER_RADIUS);
        }

    },    
    paintSun = function (context) {
       context.save();

       context.strokeStyle = 'LightSlateGray';
       context.fillStyle = 'LightGoldenRodYellow';
       context.lineWidth = 1;

       context.beginPath();
       context.arc(SUN_LEFT, SUN_TOP, SUN_RADIUS, 0, Math.PI*2, true);
       context.fill();
       context.stroke();

       context.restore();
    },
    paintFarCloud=function(context,x,y){
        context.save();
        context.lineWidth=0.5; 
        context.strokeStyle='rgba(100,140,230,0,0.8)';
        context.fillStyle='rgba(255,255,255,0.4)';
        context.beginPath();

        context.moveTo(x+102,y+91);
        //draw Adds a quadratic Bézier curve to the current path.
        context.quadraticCurveTo(x+180, y+110, x+250, y+90);
        context.quadraticCurveTo(x+312, y+87, x+279, y+60);
        context.quadraticCurveTo(x+321, y+20, x+265, y+20);
        context.quadraticCurveTo(x+219, y+4, x+171, y+23);
        context.quadraticCurveTo(x+137, y+5, x+104, y+18);
        context.quadraticCurveTo(x+57, y+23, x+79, y+48);
        context.quadraticCurveTo(x+57, y+74, x+104, y+92);
        context.closePath();
        context.stroke();
        context.fill();
        context.restore();
    },

    paintNearCloud=function(context,x,y){
       context.save();
       context.lineWidth=0.5;
       context.strokeStyle='rgba(100, 140, 230, 0, 0.8)';
       context.fillStyle='rgba(255,255,255,0.4)';
       context.beginPath();

       context.fillStyle='rgba(255,255,255,0.7)';

       context.moveTo(x+364, y+37);
       context.quadraticCurveTo(x+426, y+28, x+418, y+72);
       context.quadraticCurveTo(x+450, y+123, x+388, y+114);
       context.quadraticCurveTo(x+357, y+144, x+303,y+ 115);
       context.quadraticCurveTo(x+251, y+118, x+278, y+83);
       context.quadraticCurveTo(x+254, y+46, x+320, y+46);
       context.quadraticCurveTo(x+326, y+12, x+362, y+37);
       context.closePath();
       context.stroke();
       context.fill();
       context.restore();    
    },

    //Painter
    ballPainter={
        paint:function(sprite,context){
            let x=sprite.left+sprite.width,
                y=sprite.top+sprite.height,
                width=sprite.width,
                height=sprite.height;

            context.save();
            Arc.drawRoundedRect(BALL_STROKE_STYLE,BALL_FILL_STYLES,
                                            x,y,width,height,CORNER_RADIUS)
            context.restore();
        }
    },
//Sprite 
    ballSprite=new Sprite('ball',ballPainter,[Behavior.moveBall,Behavior.fallOnLedge]),

//Game over
    over=function(that){
        let highScore,
            highScores=game.getHighScores();
        if(highScores.length===0||score>highScores[0].score){
            showHighScores(that); //App 
        }
        else{
            //gameOverToast.style.display = 'inline';
            that.setState({
                overDisplay:'inline' //change it to the top level
            });
        }

        gameOver=true;
        lastScore=score;
        score=0;
    },



//Pause and Auto-pause Event handler...................................
    togglePaused=function(that){ //that object in jsx
        game.togglePaused();
        //pausedToast.style.display = game.paused ? 'inline' : 'none';
        let displayx=game.paused?'inline':'none';
        that.setState({
            display:displayx
        });
        
    },

    pauseToastClickHandler=function(e){
        //this --> the object in JSX
        this.setState({
            display:'none'
        });
        togglePaused(this);
    };

// 离开浏览器 失去焦点时触发
function windowOnBlur(that){
    console.log(loading,gameOver,game.paused);
    if(!loading && !gameOver&& !game.paused){
        togglePaused(that);
        let displayx=game.paused?'inline':'none';
        that.setState({  
            display:displayx
        });
    }
    //console.log('sss');
}

function windowOnFocus(that){
    if(game.paused){
        togglePaused(that);
        let displayx=game.paused?'inline':'none';
        that.setState({
            display:displayx
        });
    }
    //console.log('eee');
}

//New Game..................................
//Actually this belongs to the over Compoent
let newGameClickHandler=function(e){
        this.setState({
            overDisplay:'none'
        });
        startNewGame();
    };

function startNewGame(){
    //highScoreParagraph.style.display = 'none';
    gameOver=false;
    livesLeft=1;
    score=0;

}

//High Scores
//Change game display to show high scores when player
//beats the high score
let showHighScores=function(that){
        //highScore  //
        that.setState({
            highScoreDisplay:'inline'
        });
        //livesLeft
        updateHighScoreList(that);
        that.setState({
            highScoreName:0 //0 focus 1 lost focus
        });
    },

    updateHighScoreList=function(that){
        let el,
            highScores=game.getHighScores(),
            length=highScores.length,
            highScore;
            //listParent  not necessary
        //highScoreList.id = 'highScoreList'; // Set up CSS of list
        if(length>0){
            that.setState({
                preScoreDisplay:'block'
            });
            length=length>10?10:length;
            //render high score list
            that.setState({
                rank:highScores
            });

        }else{
            that.setState({
                preScoreDisplay:'none'
            });
        }
    },

    addScoreClickHandler=function(e){
        game.setHighScore({name:this.state.nameValue,score:lastScore});
        updateHighScoreList();
        this.setState({
            buttonDisable:true,
            nameValue:''
        });
    },

    newGameFromScoreClickHandler=function(e){
        this.setState({
            highScoreDisplay:'none'
        });
        startNewGame();
    },

    nameInputKeyUpHandler=function(e){
        if(this.state.nameValue.length>0){
            this.setState({
                buttonDisable:false
            });
        }
        else{
            this.setState({
                buttonDisable:true
            });
        }
    };

//Score Display
    function updateScore (that) {
        // body... 
        if(!loading&& game.lastScoreUpdate!==undefined){
            if(game.gameTime-game.lastScoreUpdate>1000){
                that.setState({
                    scoreDisplay:'inline'
                });
                score+=10;
                //scoreToast.innerHTML = score.toFixed(0);
                game.lastScoreUpdate=game.gameTime;
            }
        }else{
            game.lastScoreUpdate=game.gameTime;
        }
    }

//End game button
let clearHighScoresCheckHandler=function(e){
        if(this.state.clearAll){
            game.clearHighScores();
        }
    },
    //LoadScore handler
    loadScoreDisplayHandler=function(){
        let newStateObj={
            scoreDisplay:'inline',
            scoreText:'10'
        };
        loading=false;
        score=10;
        //console.log('loading Score');
        game.playSound('pop');     
        return newStateObj;
    }

//Util  Function
//需要异步改变这个颜色。
function generateRandom(){
    //实际上是对数组下标的随机生成。 
    let colorIndex=Math.floor(Math.random()*FILL_STYLES.length);
    return FILL_STYLES[colorIndex];
}

function initalColor(){
    let initial=generateRandom();
    spriteColor.push(initial);
    for(var i=0;i<RECT_NUM;i++){
        ranColor.push(initial);
    }
}
//handle Game event
function handleGame(){}


setInterval(()=>{
    let color=generateRandom();
    ranColor.shift();
    ranColor.push(color);
    //Event.trigger('colorChange',ranColor);
},5000);


//Load game ....................................................
//Running the game Here 
loading=true;
//Adding Sprite here
//INITALIZE
 ballSprite.top=BALL_LAUNCH_TOP;
 ballSprite.left=BALL_LAUNCH_LEFT;
ballSprite.width=BALL_WIDTH;
ballSprite.height=BALL_HEIGHT;
game.addSprite(ballSprite);
initalColor();
let loadButtonHandler=function(e){
    let interval,loadingPercentComplete=0;
    e.preventDefault();
    //Inside handler  don't use this! 
    this.setState({
        loadButtonDisplay:'none',
        loadMsgDisplay:'block',
        progressDivDisplay:'block'
    });
    //progressDiv.appendChild(progressbar.domElement);
    //No problem it's url of image , not physical path
    game.queueImage('/public/waterfall.png');
    game.queueImage('/public/tree.png');
    //Supposed to rewrite it with Promise!
    //Interval is the return value of setInterval 
    interval=setInterval((e)=>{
        loadingPercentComplete=game.loadImages();
        if(loadingPercentComplete===100){
            clearInterval(interval);
            setTimeout((e)=>{
                this.setState({
                    loadMsgDisplay:'none',
                    progressDivDisplay:'none'
                });
                setTimeout((e)=>{
                    this.setState({
                        loadingTitle:'none'
                    });
                    setTimeout((e)=>{
                        this.setState({
                            loadingToastDisplay:'none'
                        })
                        game.playSound('pop');
                        setTimeout((e)=>{
                            //Trigger the user-defined event. 
                            Event.trigger('LoadScore');
                            console.log('here');
                        },1000);
                    },500);
                },500);
            },500);
        }
         //progressbar.draw(loadingPercentComplete);
    },16)
}

//Game Paint Method override
game.startAnimate=function(){

};
//called after thr sprites are painted
game.paintOverSprites=function(){
    scrollBackground();
};

//Called before the sprite is painted 
game.paintUnderSprites=function(){//Draw things other than sprites
    if(!gameOver&& livesLeft===0 ){///gameOver==false
        over(that); //here call over 
        ///事件 观察者模式， 订阅over事件，因为这个需要在
        ///处理函数中调用 this.setState, 我选择了直接传入this来处理
        ///这样就需要在App.jsx 中，利用arrow function来处理，但是其实
        ///我不应该在业务逻辑直接this.setState来改变状态，而应该
        ///把状态改变了之后返回给 React组件，在React组件里面通过事件
        ///来获取这个改变后的state值，然后更新state。 其实也就是说
        ///我的React里面的某个事件会触发这个state改变，但是改变是在
        ///我业务逻辑中实现的 
        Event.trigger('over');
    }else{
        paintSun(game.context);

        if(!gameOver){
            //updateScore(that); 
            Event.trigger('updateScore');
        }
    }
};

game.endAnimate=function(){

}


export {
    over,updateScore,
    togglePaused,pauseToastClickHandler,
    windowOnBlur,windowOnFocus,
    newGameClickHandler,
    addScoreClickHandler,
    newGameFromScoreClickHandler,
    nameInputKeyUpHandler,
    clearHighScoresCheckHandler,
    loadButtonHandler,
    loadScoreDisplayHandler,
    startNewGame,
    game
};